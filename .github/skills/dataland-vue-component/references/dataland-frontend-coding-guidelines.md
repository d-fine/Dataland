# ðŸŽ¨ Frontend and UX Overview

This section covers the design and frontend development aspects of Dataland, including UI guidelines and mockups.

## Frontend Development Rules
These rules apply in particular whenever a new Frontend Component is developped.

### PrimeVue
1. **Read the PrimeVue API.** PrimeVue provides everything you need. 
1. **Understand the PrimeVue API.** PrimeVue provides everything you need. 
1. **Do not build unneccessary component wrappers.** Find the appropriate component, read and understand the component API, and check the properties provided by the component.
1. **Use the component's API to modify its behaviour.**
1. **Do not use FormKit.** FormKit comes with its own UI. Use the form elements provided by PrimeVue instead. If you need a proper validation, use `zod` as validation tool. Confer the PrimeVue examples for more information: https://primevue.org/inputtext/#forms . Click "Toggle Full Code" to see how `zod` is used.
1. **Do not access the PrimeVue CSS classes on a local scope.** Modify a component's styling globally by modifying the according preset.
1. **Do not use `:deep()`.** If you really need to customize a single component, use PrimeVue's PassThrough API. If you don't know how this works, ask a fellow developer or don't customize at all.

### Frontend Layout, Styling, CSS
1. **Do not use PrimeFlex classes.** PrimeFlex is sunsetted.
1. **Do not use material icons.** Use prime icons instead.
1. **Do not use scoped styles** if not absolutely necessary.
1. **Do not modify the design of PrimeVue components via scoped styles.**
1. **Use PrimeVue's Design-Tokens to modify the design of PrimeVue components.** 
   * Each Design-Token corresponds to a CSS variable.
   * Make use of these CSS variables.
1. **Do not use `:deep()`.** If you really need to customize a single component, use PrimeVue's PassThrough API. If you don't know how this works, ask a fellow developer or don't customize at all.
1. **Using scoped styles is only admissible for structuring the general layout** of your component and positioning your elements.
   * For structuring your component, use `div`-containers with custom CSS classes.
   * Your custom CSS classes may only modify structural CSS properties like `display` (`grid` or `flex`), `padding`, `margin` and so on.
   * If you want to modify the design for a single component, don't. If you think it is necessary, it is not. If you still think it is necessary, re-use the CSS variables automatically generated by the Design-Tokens
1. **Do not copy old code.** Work under the assumption that the code you're looking at does not follow the best practices laid out by these rules.

## Useful tools
* [Gradient Generator](https://colordesigner.io/gradient-generator)
* [Color Picker](https://colorpicker.dev)
* [Common VueJs Mistakes and How to Avoid Them](https://vueschool.io/courses/common-vue-js-mistakes-and-how-to-avoid-them) This is a free and strongly recommended video course on the most common mistakes in coding Vue.

## Specific code guidelines
### CSS
We write and manage our CSS ourselves via SCSS-files in our repo, which serve as single-source-of-truth for general stylings, and ```<style scoped>``` sections inside of our Vue-components.
If you want to create a new CSS-class, do that according to the following rules:
1. If your CSS-class is only used inside of one Vue-component, then add the class by using the ```<style scoped>``` inside of that Vue-component.
2. If your CSS-class is meant to serve as general styling of elements in Dataland (or in other words: If your CSS-class is used in multiple Vue-components), add that CSS-class in the central SCSS-files.

### TypeScript in Vue
* If new Vue components are created or old ones refactored: Add the <script lang="ts"> tag  to use TypeScript.
* New VueJs-components should be written using the Composition API of VueJs
* If you change an existing VueJs-component that uses the Options API of VueJs, it is ok to not migrate it to Composition API. 

### URLs in Frontend
The paths in the router of the Frontend, which define a one-to-one-mapping of dataland.com URLs to specific Vue-components, should also be based on the Rest API [Resource Naming Convention](https://restfulapi.net/resource-naming/) with small adjustments:

1. URLs for pages without upload functionalities are named according to GET-endpoints in a Rest API. E.g. the path to view the framework data for one specific company would be "_/companies/:companyID/frameworks/:frameworkName_" where _:companyID_ and _:frameworkName_ must of course have actual valid values.
2. URLs for pages with upload functionalities (POST-URLs so to speak) just need a prefix "_/upload_" attached to the respective URL, which a user would visit afterwards to view the data.
So to upload framework data for one specific company a user needs to visit "_/companies/:companyID/frameworks/:frameworkName/upload_".

### "Framework Data View Page"

#### What is the "Framework Data View Page"
The Framework Data View Page is the page in the UI where a user can view one or multiple Dataland datasets with all values. It is a very important feature of the Dataland product. 

#### Centralized logic
The logic of the Framework Data View Page is highly centralized in the source code. For instance, there is _one_ logic that decides how a percentage value shall be displayed on the Framework Data View Page, no matter the framework. A Dataland framework is a standardized "report" for which users can upload datasets. Let's say tomorrow a new framework is introduced to Dataland with the name "d-fine employee profile" with fields like "name", "age", "employee number", "salary" etc.
The field "name" might be a string-field, and the "salary"-field might be a currency-number-field.
The display of these values on the view-page could and should **not** be specificly customized for this new framework. It will use the "standard behavior" for string- and currency-number-fields to display the values.

#### Implementing this logic
Sometimes we want to adjust the display of one specific kind of value (e.g. the display of percentage-nubmer-fields). Whenever we do this, we do this for _all_ frameworks.
An absolute anti-pattern here is that the raw framework data is being manipulated in multiple steps until it reaches the VueJs-component that is responsible for its display. Instead of this anti-pattern, the raw data shall either be formatted _once_ at the very beginning of the processing steps, and then not be manipulated anymore until it is passed to the VueJs-component that will display it.
This makes it much easier to maintain or adjust the logic for field types.