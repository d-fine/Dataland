import { assertDefined } from "@/utils/TypeScriptUtils";
import {
  type CompanyAssociatedDataEuTaxonomyDataForNonFinancials,
  type DataMetaInformation,
  DataTypeEnum,
  type EuTaxonomyDataForFinancials,
  type EuTaxonomyDataForNonFinancials,
} from "@clients/backend";
import { describeIf } from "@e2e/support/TestUtility";
import { getKeycloakToken } from "@e2e/utils/Auth";
import { generateDummyCompanyInformation, uploadCompanyViaApi } from "@e2e/utils/CompanyUpload";
import { TEST_PDF_FILE_NAME, TEST_PDF_FILE_PATH } from "@sharedUtils/ConstantsForPdfs";
import { admin_name, admin_pw, getBaseUrl, uploader_name, uploader_pw } from "@e2e/utils/Cypress";
import { uploadDocumentViaApi } from "@e2e/utils/DocumentUpload";
import {
  fillAndValidateEuTaxonomyForNonFinancialsUploadForm,
  uploadEuTaxonomyDataForNonFinancialsViaForm,
} from "@e2e/utils/EuTaxonomyNonFinancialsUpload";
import {
  goToEditFormOfMostRecentDatasetForCompanyAndFramework,
  uploadCompanyViaApiAndEuTaxonomyDataViaForm,
} from "@e2e/utils/GeneralUtils";
import { type FixtureData, getPreparedFixture } from "@sharedUtils/Fixtures";
import { uploadDocuments } from "@sharedUtils/components/UploadDocuments";
import Chainable = Cypress.Chainable;
import { submitFilledInEuTaxonomyForm } from "@e2e/utils/EuTaxonomyFinancialsUpload";
import { fr } from "@faker-js/faker";

describeIf(
  "As a user, I expect that the upload form works correctly when editing and uploading a new eu-taxonomy dataset for a non-financial company",
  {
    executionEnvironments: ["developmentLocal", "ci", "developmentCd"],
  },
  function () {
    let frontendDocumentHash = "";
    let testData: FixtureData<EuTaxonomyDataForNonFinancials>;
    before(function () {
      cy.fixture("CompanyInformationWithEuTaxonomyDataForNonFinancials").then(function (
        jsonContent: FixtureData<EuTaxonomyDataForNonFinancials>[],
      ) {
        testData = jsonContent[0];
      });
    });

    /**
     * Visits the edit page for the eu taxonomy dataset for non financial companies via navigation and then checks
     * if already uploaded reports do exist in the form.
     * @param companyId the id of the company for which to edit a dataset
     * @param expectPdfTest specifies if the test file is expected to be in the server response
     */
    function goToEditFormAndValidateExistenceOfReports(companyId: string, expectPdfTest: boolean): void {
      goToEditFormOfMostRecentDatasetForCompanyAndFramework(companyId, DataTypeEnum.EutaxonomyNonFinancials).then(
        (interception) => {
          const referencedReports = assertDefined(
            (interception?.response?.body as CompanyAssociatedDataEuTaxonomyDataForNonFinancials)?.data.general
              ?.referencedReports,
          );
          expect(TEST_PDF_FILE_NAME in referencedReports).to.equal(expectPdfTest);
          expect(`${TEST_PDF_FILE_NAME}2` in referencedReports).to.equal(true);
        },
      );
    }

    /**
     * Checks that the computed hash in the frontend is the same as the one returned by the document upload endpoint
     * @param keycloakToken token given by keycloak after logging in
     * @param frontendDocumentHash calculated hash of the document
     */
    function validateFrontendAndBackendDocumentHashesCoincede(
      keycloakToken: string,
      frontendDocumentHash: string,
    ): void {
      cy.task<{ [type: string]: ArrayBuffer }>("readFile", `../${TEST_PDF_FILE_PATH}`).then(async (bufferObject) => {
        await uploadDocumentViaApi(keycloakToken, bufferObject.data, TEST_PDF_FILE_PATH).then((response) => {
          expect(frontendDocumentHash).to.equal(response.documentId);
        });
      });
    }

    // it(
    //   "Check if the file upload info remove button works as expected and make sure the file content hashes" +
    //     "generated by frontend and backend are the same",
    //   () => {
    //     getKeycloakToken(admin_name, admin_pw).then((token: string) => {
    //       return uploadCompanyViaApi(
    //         token,
    //         generateDummyCompanyInformation(testData.companyInformation.companyName),
    //       ).then((storedCompany) => {
    //         cy.ensureLoggedIn(admin_name, admin_pw);
    //         cy.visitAndCheckAppMount(
    //           `/companies/${storedCompany.companyId}/frameworks/${DataTypeEnum.EutaxonomyNonFinancials}/upload`,
    //         );
    //         uploadDocuments.selectFile(TEST_PDF_FILE_NAME, "referencedReports");
    //         uploadDocuments.selectFile(`${TEST_PDF_FILE_NAME}2`, "referencedReports");
    //         uploadDocuments.fillAllFormsOfReportsSelectedForUpload(2);
    //         fillAndValidateEuTaxonomyForNonFinancialsUploadForm(false, `${TEST_PDF_FILE_NAME}2`);
    //         cy.get('div[name="revenue"]').within(() => {
    //           cy.get('select[name="report"]').select(TEST_PDF_FILE_NAME);
    //         });
    //         cy.get('div[name="capex"]').within(() => {
    //           cy.get('select[name="report"]').select(`${TEST_PDF_FILE_NAME}2`);
    //         });
    //         cy.intercept({ method: "POST", url: `**/api/data/**`, times: 1 }, (request) => {
    //           const data = assertDefined((request.body as CompanyAssociatedDataEuTaxonomyDataForNonFinancials).data);
    //           expect(TEST_PDF_FILE_NAME in assertDefined(data.general?.referencedReports)).to.equal(true);
    //           expect(`${TEST_PDF_FILE_NAME}2` in assertDefined(data.general?.referencedReports)).to.equal(true);
    //           frontendDocumentHash = assertDefined(data.general?.referencedReports)[TEST_PDF_FILE_NAME].reference;
    //         }).as("postData");
    //         cy.get('button[data-test="submitButton"]').click();
    //
    //         cy.wait(`@postData`, { timeout: Cypress.env("long_timeout_in_ms") as number }).then((interception) => {
    //           validateFrontendAndBackendDocumentHashesCoincede(token, frontendDocumentHash);
    //           console.log("1 frontendDocumentHash", frontendDocumentHash);
    //           expect(interception.response?.statusCode).to.eq(200);
    //         });
    //         cy.contains("td", "EU Taxonomy");
    //         goToEditFormAndValidateExistenceOfReports(storedCompany.companyId, true);
    //         uploadDocuments.removeAlreadyUploadedReport(TEST_PDF_FILE_NAME);
    //
    //         cy.intercept(
    //           {
    //             method: "POST",
    //             url: `**/api/data/**`,
    //             times: 1,
    //           },
    //           (request) => {
    //             const data = assertDefined((request.body as CompanyAssociatedDataEuTaxonomyDataForNonFinancials).data);
    //             expect(TEST_PDF_FILE_NAME in assertDefined(data.general?.referencedReports)).to.equal(false);
    //             expect(`${TEST_PDF_FILE_NAME}2` in assertDefined(data.general?.referencedReports)).to.equal(true);
    //           },
    //         ).as("postEdit");
    //         cy.get('button[data-test="submitButton"]').click();
    //         cy.wait(`@postEdit`, { timeout: Cypress.env("long_timeout_in_ms") as number }).then((interception) => {
    //           expect(interception.response?.statusCode).to.eq(200);
    //         });
    //         goToEditFormAndValidateExistenceOfReports(storedCompany.companyId, false);
    //       });
    //     });
    //   },
    // );

    /* TODO Emanuel:
    The following test seems a little overkill, but parts of it definitely make sense from my perspective:
    - This test actually downloads a report. But this is not possible anymore for eu taxo non financials, because it
      is displayed as a multiview page currently.  Therefore I suggest migrating this test to the framework eu taxo
      financials, which is still a single view framework, and therefore has a banner to download a report.
    - This test also covers our document upload logic (don't upload if hash already exists etc.).  This part of the
      the test could also be migrated to a eu taxo financials test.

    Parts that do not make sense in my opinion:
    - You don't need to upload stuff via the form here in my opinion.  This is already covered by the first test in this
      test file here.  You can replace that by a simple api upload.
*/
    it(
      "Upload EU Taxonomy Dataset via form, check that redirect to MyDatasets works and assure that it can be " +
        "viewed and edited, and that file selection, upload and download works properly",
      () => {
        getKeycloakToken(admin_name, admin_pw).then((token) => {
          return uploadCompanyViaApi(token, generateDummyCompanyInformation("All fields filled")).then(
            (storedCompany) => {
              cy.ensureLoggedIn(admin_name, admin_pw);
              uploadEuTaxonomyDataForNonFinancialsViaForm(storedCompany.companyId);
              cy.url().should("eq", getBaseUrl() + "/datasets");

              cy.visitAndCheckAppMount(
                `/companies/${storedCompany.companyId}/frameworks/${DataTypeEnum.EutaxonomyNonFinancials}`,
              );

              cy.get("[data-test='companyNameTitle']").contains("All fields filled");

              clickEditButtonAndEditAndValidateChange(storedCompany.companyId).then((templateDataId) => {
                checkThatFilesWithSameContentDontGetReuploaded(storedCompany.companyId, templateDataId);
              });
            },
          );
        });
      },
    );

    /**
     * On the eu taxonomy for non-financial services view page, this method edits some data and validates the changes
     * @param companyId the ID of the company on whose view page this method starts on
     * @returns a chainable on the data ID of the created dataset
     */
    function clickEditButtonAndEditAndValidateChange(companyId: string): Chainable<string> {
      const newValueForEligibleRevenueAfterEdit = "30";
      cy.intercept(`**/api/data/${DataTypeEnum.EutaxonomyNonFinancials}/*`).as("getDataToPrefillForm");
      cy.get('button[data-test="editDatasetButton"]').click();
      cy.wait("@getDataToPrefillForm");
      cy.get('[data-test="pageWrapperTitle"]').should("contain", "Edit");
      cy.get(`div[data-test=revenueSection] div[data-test=eligible] input[name="valueAsAbsolute"]`)
        .clear()
        .type(newValueForEligibleRevenueAfterEdit);
      cy.get(`div[data-test=revenueSection] div[data-test=eligible] input[name="valueAsPercentage"]`)
        .clear()
        .type(newValueForEligibleRevenueAfterEdit);
      cy.get('button[data-test="submitButton"]').click();
      cy.wait("@getDataForMyDatasetsPage");
      cy.intercept(`**/api/metadata?companyId=${companyId}`).as("getMetaDataForViewPage");
      cy.visitAndCheckAppMount(`/companies/${companyId}/frameworks/${DataTypeEnum.EutaxonomyNonFinancials}`);
      cy.contains("[data-test='taxocard']", "Eligible Revenue").should(
        "contain",
        newValueForEligibleRevenueAfterEdit + "%",
      );
      return cy.wait("@getMetaDataForViewPage").then((interception) => {
        return assertDefined(
          (assertDefined(interception.response).body as DataMetaInformation[]).find(
            (dataMetaInfo) => dataMetaInfo.currentlyActive,
          ),
        ).dataId;
      });
    }

    const differentFileNameForSameFile = `${TEST_PDF_FILE_NAME}FileCopy`;

    /**
     * This method verifies that there are no files with the same content uploaded twice
     * @param companyId the ID of the company whose data is to be edited
     * @param templateDataId the ID of the dataset to edit
     */
    function checkThatFilesWithSameContentDontGetReuploaded(companyId: string, templateDataId: string): void {
      cy.visitAndCheckAppMount(
        `/companies/${companyId}/frameworks/${DataTypeEnum.EutaxonomyNonFinancials}/upload?templateDataId=${templateDataId}`,
      );
      cy.wait("@getDataToPrefillForm");
      cy.get('[data-test="pageWrapperTitle"]').should("contain", "Edit");
      cy.get("input[type=file]").selectFile(
        {
          contents: `../${TEST_PDF_FILE_PATH}`,
          fileName: differentFileNameForSameFile + ".pdf",
        },
        { force: true },
      );
      uploadDocuments.fillAllFormsOfReportsSelectedForUpload();
      cy.get(`div[data-test=capexSection] div[data-test=total] select[name="report"]`).select(
        differentFileNameForSameFile,
      );
      cy.intercept({ url: `**/documents/*`, method: "HEAD" }).as("documentExists");
      cy.intercept(`**/documents/`, cy.spy().as("postDocument"));
      cy.intercept(`**/api/data/${DataTypeEnum.EutaxonomyNonFinancials}`).as("postCompanyAssociatedData");
      console.log('LLLLLLLLLLL')
      cy.get('button[data-test="submitButton"]').click();
      cy.wait("@documentExists", { timeout: Cypress.env("short_timeout_in_ms") as number })
        .its("response.statusCode")
        .should("equal", 200);
      cy.wait("@postCompanyAssociatedData", { timeout: Cypress.env("short_timeout_in_ms") as number }).then((req) => {
        cy.log(assertDefined(req.response).body as string);
      });
      cy.wait("@getDataForMyDatasetsPage");
      cy.get("@postDocument").should("not.have.been.called");
    }
  },
);
