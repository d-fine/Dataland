import { assertDefined } from "@/utils/TypeScriptUtils";
import {
  CompanyAssociatedDataEuTaxonomyDataForNonFinancials,
  DataMetaInformation,
  DataTypeEnum,
  EuTaxonomyDataForFinancials,
  EuTaxonomyDataForNonFinancials,
} from "@clients/backend";
import { describeIf } from "@e2e/support/TestUtility";
import { getKeycloakToken } from "@e2e/utils/Auth";
import { generateDummyCompanyInformation, uploadCompanyViaApi } from "@e2e/utils/CompanyUpload";
import { TEST_PDF_FILE_NAME, TEST_PDF_FILE_PATH } from "@e2e/utils/Constants";
import { admin_name, admin_pw, getBaseUrl } from "@e2e/utils/Cypress";
import { uploadDocumentViaApi } from "@e2e/utils/DocumentUpload";
import {
  fillAndValidateEuTaxonomyForNonFinancialsUploadForm,
  uploadEuTaxonomyDataForNonFinancialsViaForm,
} from "@e2e/utils/EuTaxonomyNonFinancialsUpload";
import {
  goToEditFormOfMostRecentDataset,
  uploadCompanyViaApiAndEuTaxonomyDataViaForm,
} from "@e2e/utils/GeneralApiUtils";
import { FixtureData, getPreparedFixture } from "@sharedUtils/Fixtures";
import { uploadDocuments } from "@sharedUtils/components/UploadDocuments";
import Chainable = Cypress.Chainable;

describeIf(
  "As a user, I expect that the upload form works correctly when editing and uploading a new eu-taxonomy dataset for a non-financial company",
  {
    executionEnvironments: ["developmentLocal", "ci", "developmentCd"],
    dataEnvironments: ["fakeFixtures"],
  },
  function () {
    beforeEach(() => {
      cy.ensureLoggedIn(admin_name, admin_pw);
    });

    let testData: FixtureData<EuTaxonomyDataForNonFinancials>;

    before(function () {
      cy.fixture("CompanyInformationWithEuTaxonomyDataForFinancialsPreparedFixtures").then(function (jsonContent) {
        const preparedFixtures = jsonContent as Array<FixtureData<EuTaxonomyDataForFinancials>>;
        testData = getPreparedFixture("company-for-all-types", preparedFixtures);
      });
    });

    let keycloakToken = "";
    let frontendDocumentHash = "";

    /**
     * Visits the edit page for the eu taxonomy dataset for non financial companies via navigation.
     * @param companyId the id of the company for which to edit a dataset
     * @param expectPdfTest specifies if the test file is expected to be in the server response
     */
    function goToEditForm(companyId: string, expectPdfTest: boolean): void {
      goToEditFormOfMostRecentDataset(companyId, DataTypeEnum.EutaxonomyNonFinancials).then((interception) => {
        const referencedReports = assertDefined(
          (interception?.response?.body as CompanyAssociatedDataEuTaxonomyDataForNonFinancials)?.data?.referencedReports
        );
        expect(TEST_PDF_FILE_NAME in referencedReports).to.equal(expectPdfTest);
        expect(`${TEST_PDF_FILE_NAME}2` in referencedReports).to.equal(true);
      });
    }

    /**
     * Checks that dialog for "file can not be selected" is open and closes it
     */
    function validateFileCanNotBeUploadedDialogIsOpenAndClose(): void {
      cy.contains(".p-dialog-content", "file cannot be selected").should("exist");
      cy.get(".p-dialog-header-close").click();
    }

    /**
     * Checks that dialog for "file can not be selected" is closed
     */
    function validateFileCanNotBeUploadedDialogIsClosed(): void {
      cy.contains(".p-dialog-content", "file cannot be selected").should("not.exist");
    }

    it(
      "Check if the file upload info remove button works as expected and make sure the file content hashes" +
        "generated by frontend and backend are the same",
      () => {
        testData.companyInformation.companyName = "non-financials-upload-form-remove-document-button";

        getKeycloakToken(admin_name, admin_pw).then((token: string) => {
          keycloakToken = token;

          uploadCompanyViaApiAndEuTaxonomyDataViaForm(
            DataTypeEnum.EutaxonomyNonFinancials,
            testData.companyInformation,
            undefined,
            () => {
              uploadDocuments.selectDummyFile("dummy_1", 1);
              uploadDocuments.numberOfReportsToUploadShouldBe(1);
              validateFileCanNotBeUploadedDialogIsClosed();
              uploadDocuments.selectDummyFile("dummy_1", 1);
              uploadDocuments.numberOfReportsToUploadShouldBe(1);
              validateFileCanNotBeUploadedDialogIsClosed();
              uploadDocuments.selectDummyFile("dummy_1", 2);
              validateFileCanNotBeUploadedDialogIsOpenAndClose();
              uploadDocuments.numberOfReportsToUploadShouldBe(1);
              uploadDocuments.removeAllReportsToUpload();

              uploadDocuments.numberOfReportsToUploadShouldBe(0);
              uploadDocuments.selectFile(TEST_PDF_FILE_NAME);
              uploadDocuments.selectFile(`${TEST_PDF_FILE_NAME}2`);
              uploadDocuments.fillAllReportsToUploadForms(2);

              fillAndValidateEuTaxonomyForNonFinancialsUploadForm(false, `${TEST_PDF_FILE_NAME}2`);

              cy.get(`[data-test="capexSection"] [data-test="total"] select[name="report"]`).select(TEST_PDF_FILE_NAME);
              cy.get(`[data-test="opexSection"] [data-test="total"] select[name="report"]`).select(
                `${TEST_PDF_FILE_NAME}2`
              );
            },
            (request) => {
              const data = assertDefined((request.body as CompanyAssociatedDataEuTaxonomyDataForNonFinancials).data);
              frontendDocumentHash = assertDefined(data.referencedReports)[TEST_PDF_FILE_NAME].reference;
              expect(TEST_PDF_FILE_NAME in assertDefined(data.referencedReports)).to.equal(true);
              expect(`${TEST_PDF_FILE_NAME}2` in assertDefined(data.referencedReports)).to.equal(true);
            },
            (companyId) => {
              goToEditForm(companyId, true);
              uploadDocuments.removeUploadedReport(TEST_PDF_FILE_NAME);
              const postRequestAlias = "postData";
              cy.intercept(
                {
                  method: "POST",
                  url: `**/api/data/**`,
                  times: 1,
                },
                (request) => {
                  const data = assertDefined(
                    (request.body as CompanyAssociatedDataEuTaxonomyDataForNonFinancials).data
                  );
                  expect(TEST_PDF_FILE_NAME in assertDefined(data.referencedReports)).to.equal(false);
                  expect(`${TEST_PDF_FILE_NAME}2` in assertDefined(data.referencedReports)).to.equal(true);
                }
              ).as(postRequestAlias);
              cy.get('button[data-test="submitButton"]').click();
              cy.wait(`@${postRequestAlias}`, { timeout: Cypress.env("long_timeout_in_ms") as number }).then(
                (interception) => {
                  expect(interception.response?.statusCode).to.eq(200);
                }
              );
              goToEditForm(companyId, false);
              validateFrontendAndBackendDocumentHashesCoincede();
            }
          );
        });
      }
    );

    /**
     * Checks that the computed hash in the frontend is the same as the one returned by the documen upload endpoint
     */
    function validateFrontendAndBackendDocumentHashesCoincede(): void {
      cy.task<{ [type: string]: ArrayBuffer }>("readFile", `../${TEST_PDF_FILE_PATH}`).then(async (bufferObject) => {
        await uploadDocumentViaApi(keycloakToken, bufferObject.data, TEST_PDF_FILE_PATH).then((response) => {
          expect(frontendDocumentHash).to.equal(response.documentId);
        });
      });
    }

    it(
      "Upload EU Taxonomy Dataset via form, check that redirect to MyDatasets works and assure that it can be " +
        "viewed and edited, and that file selection, upload and download works properly",
      () => {
        getKeycloakToken(admin_name, admin_pw).then((token) => {
          return uploadCompanyViaApi(token, generateDummyCompanyInformation("All fields filled")).then(
            (storedCompany) => {
              cy.intercept(`**/companies**`).as("getDataForMyDatasetsPage");
              uploadEuTaxonomyDataForNonFinancialsViaForm(storedCompany.companyId);
              cy.url().should("eq", getBaseUrl() + "/datasets");
              cy.wait("@getDataForMyDatasetsPage");

              cy.visitAndCheckAppMount(
                `/companies/${storedCompany.companyId}/frameworks/${DataTypeEnum.EutaxonomyNonFinancials}`
              );

              cy.get("[data-test='companyNameTitle']").contains("All fields filled");
              checkAllDataProvided();
              clickEditButtonAndEditAndValidateChange(storedCompany.companyId).then((templateDataId) => {
                checkFileWithExistingFilenameCanNotBeResubmitted();
                checkExistingFilenameDialogDidNotBreakSubsequentSelection();
                checkThatFilesMustBeReferenced();
                checkThatFilesWithSameContentDontGetReuploaded(storedCompany.companyId, templateDataId);
                checkIfLinkedReportsAreDownloadable(storedCompany.companyId);
              });
            }
          );
        });
      }
    );

    /**
     * On the eu taxonomy for non-financial services view page, this method verifies that all data was provided
     */
    function checkAllDataProvided(): void {
      cy.contains("[data-test='taxocard']", "Eligible Revenue").should("contain", "%");
      cy.contains("[data-test='taxocard']", "Aligned Revenue").should("contain", "%");
      cy.contains("[data-test='taxocard']", "Eligible CapEx").should("contain", "%");
      cy.contains("[data-test='taxocard']", "Aligned CapEx").should("contain", "%");
      cy.contains("[data-test='taxocard']", "Eligible OpEx").should("contain", "%");
      cy.contains("[data-test='taxocard']", "Aligned OpEx").should("contain", "%");
    }

    /**
     * On the eu taxonomy for non-financial services view page, this method edits some data and validates the changes
     * @param companyId the ID of the company on whose view page this method starts on
     * @returns a chainable on the data ID of the created dataset
     */
    function clickEditButtonAndEditAndValidateChange(companyId: string): Chainable<string> {
      const newValueForEligibleRevenueAfterEdit = "30";
      cy.intercept(`**/api/data/${DataTypeEnum.EutaxonomyNonFinancials}/*`).as("getDataToPrefillForm");
      cy.get('button[data-test="editDatasetButton"]').click();
      cy.wait("@getDataToPrefillForm");
      cy.get('[data-test="pageWrapperTitle"]').should("contain", "Edit");
      cy.get(`div[data-test=revenueSection] div[data-test=eligible] input[name="value"]`)
        .clear()
        .type(newValueForEligibleRevenueAfterEdit);
      cy.get('button[data-test="submitButton"]').click();
      cy.wait("@getDataForMyDatasetsPage");
      cy.intercept(`**/api/metadata?companyId=${companyId}`).as("getMetaDataForViewPage");
      cy.visitAndCheckAppMount(`/companies/${companyId}/frameworks/${DataTypeEnum.EutaxonomyNonFinancials}`);
      cy.contains("[data-test='taxocard']", "Eligible Revenue").should(
        "contain",
        newValueForEligibleRevenueAfterEdit + "%"
      );
      return cy.wait("@getMetaDataForViewPage").then((interception) => {
        return assertDefined(
          (assertDefined(interception.response).body as DataMetaInformation[]).find(
            (dataMetaInfo) => dataMetaInfo.currentlyActive
          )
        ).dataId;
      });
    }

    /**
     * On the eu taxonomy for non-financial services edit page, this method checks that there can not be a file uploaded
     * whose name equals the one of a file selected before
     */
    function checkFileWithExistingFilenameCanNotBeResubmitted(): void {
      cy.get('button[data-test="editDatasetButton"]').click();
      cy.wait("@getDataToPrefillForm");
      cy.get(`[data-test="${TEST_PDF_FILE_NAME}AlreadyUploadedContainer`).should("exist");
      cy.get("input[type=file]").selectFile(`../${TEST_PDF_FILE_PATH}`, { force: true });
      cy.get(".p-dialog-content").should("contain.text", "already uploaded");
      cy.get(".p-dialog-header-close").click();
      cy.get(`[data-test="${TEST_PDF_FILE_NAME}ToUploadContainer"]`).should("not.exist");
    }

    /**
     * On the eu taxonomy for non-financial services edit page, this method checks that submission is denied
     * if a report is not referenced
     */
    function checkThatFilesMustBeReferenced(): void {
      cy.get(`button[data-test="remove-${TEST_PDF_FILE_NAME}"]`).click();
      cy.get(".p-dialog-content").should("not.exist");
      cy.get("input[type=file]").selectFile(`../testing/data/documents/test-report.pdf`, { force: true });
      uploadDocuments.fillAllReportsToUploadForms();
      cy.get('[data-test="assuranceSection"] select[name="report"]').select(1);
      cy.get('[data-test="assuranceSection"] select[name="report"]').should("contain.text", "None...");
      cy.wait(100);
      cy.get('button[data-test="submitButton"]').click();
      cy.get('[data-test="failedUploadMessage"]').should("exist").should("contain.text", "test-report");
    }

    /**
     * Adds a report to upload and removes it again afterwards checking that no dialog regarding a duplicate file name
     * is wrongly triggered and that the file is correctly removed.
     */
    function checkExistingFilenameDialogDidNotBreakSubsequentSelection(): void {
      const reportName = `${TEST_PDF_FILE_NAME}2`;
      uploadDocuments.selectFile(reportName);
      cy.get(".p-dialog-content").should("not.exist");
      uploadDocuments.validateReportToUploadIsListed(reportName);
      cy.get(`[data-test="${reportName}ToUploadContainer"]`).should("exist");
      uploadDocuments.removeAllReportsToUpload();
      cy.get(`[data-test="${reportName}ToUploadContainer"]`).should("not.exist");

      uploadDocuments.reportIsNotListed(reportName);
    }

    const differentFileNameForSameFile = `${TEST_PDF_FILE_NAME}FileCopy`;

    /**
     * This method verifies that there are no files with the same content uploaded twice
     * @param companyId the ID of the company whose data is to be edited
     * @param templateDataId the ID of the dataset to edit
     */
    function checkThatFilesWithSameContentDontGetReuploaded(companyId: string, templateDataId: string): void {
      cy.visitAndCheckAppMount(
        `/companies/${companyId}/frameworks/${DataTypeEnum.EutaxonomyNonFinancials}/upload?templateDataId=${templateDataId}`
      );
      cy.wait("@getDataToPrefillForm");
      cy.get('[data-test="pageWrapperTitle"]').should("contain", "Edit");
      cy.get("input[type=file]").selectFile(
        {
          contents: `../${TEST_PDF_FILE_PATH}`,
          fileName: differentFileNameForSameFile + ".pdf",
        },
        { force: true }
      );
      uploadDocuments.fillAllReportsToUploadForms();
      cy.get(`div[data-test=capexSection] div[data-test=total] select[name="report"]`).select(
        differentFileNameForSameFile
      );
      cy.intercept({ url: `**/documents/*`, method: "HEAD" }).as("documentExists");
      cy.intercept(`**/documents/`, cy.spy().as("postDocument"));
      cy.intercept(`**/api/data/${DataTypeEnum.EutaxonomyNonFinancials}`).as("postCompanyAssociatedData");
      cy.get('button[data-test="submitButton"]').click();
      cy.wait("@documentExists", { timeout: Cypress.env("short_timeout_in_ms") as number })
        .its("response.body")
        .should("deep.equal", { documentExists: true });
      cy.wait("@postCompanyAssociatedData", { timeout: Cypress.env("short_timeout_in_ms") as number }).then((req) => {
        cy.log(assertDefined(req.response).body as string);
      });
      cy.wait("@getDataForMyDatasetsPage");
      cy.get("@postDocument").should("not.have.been.called");
    }

    /**
     * This method verifies that uploaded reports are downloadable
     * @param companyId the ID of the company whose data to view
     */
    function checkIfLinkedReportsAreDownloadable(companyId: string): void {
      cy.visitAndCheckAppMount(`/companies/${companyId}/frameworks/${DataTypeEnum.EutaxonomyNonFinancials}`);
      const expectedPathToDownloadedReport = Cypress.config("downloadsFolder") + `/${differentFileNameForSameFile}.pdf`;
      const downloadLinkSelector = `span[data-test="Report-Download-${differentFileNameForSameFile}"]`;
      cy.readFile(expectedPathToDownloadedReport).should("not.exist");
      cy.intercept("**/documents/*").as("documentDownload");
      cy.get(downloadLinkSelector).click();
      cy.wait("@documentDownload");
      cy.readFile(`../${TEST_PDF_FILE_PATH}`, "binary", {
        timeout: Cypress.env("medium_timeout_in_ms") as number,
      }).then((expectedPdfBinary) => {
        cy.task("calculateHash", expectedPdfBinary).then((expectedPdfHash) => {
          cy.readFile(expectedPathToDownloadedReport, "binary", {
            timeout: Cypress.env("medium_timeout_in_ms") as number,
          }).then((receivedPdfHash) => {
            cy.task("calculateHash", receivedPdfHash).should("eq", expectedPdfHash);
          });
          cy.task("deleteFolder", Cypress.config("downloadsFolder"));
        });
      });
    }
  }
);
